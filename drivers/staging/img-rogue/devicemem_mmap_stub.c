/*************************************************************************/ /*!
@File
@Title          Device Memory Management
@Copyright      Copyright (c) Imagination Technologies Ltd. All Rights Reserved
@Description    OS abstraction for the mmap2 interface for mapping PMRs into
                User Mode memory
@License        Strictly Confidential.
*/ /**************************************************************************/

/* our exported API */
#include "devicemem_mmap.h"

/* include/ */
#include "img_types.h"
#include "pvr_debug.h"
#include "pvrsrv_error.h"

/* services/include/ */

/* services/include/srvhelper/ */
#include "ra.h"

/* autogenerated bridge */
#include "client_mm_bridge.h"

#include "pmr.h"

IMG_INTERNAL PVRSRV_ERROR
OSMMapPMR(IMG_HANDLE hBridge,
          IMG_HANDLE hPMR,
          IMG_DEVMEM_SIZE_T uiPMRSize,
          IMG_UINT32 uiFlags,
          IMG_HANDLE *phOSMMapPrivDataOut,
          void **ppvMappingAddressOut,
          IMG_SIZE_T *puiMappingLengthOut)
{
    PVRSRV_ERROR eError;
    PMR *psPMR;
    void *pvKernelAddress;
    IMG_SIZE_T uiLength;
    IMG_HANDLE hPriv;

    PVR_UNREFERENCED_PARAMETER(hBridge);
    PVR_UNREFERENCED_PARAMETER(uiFlags);

    /*
      Normally this function would mmap a PMR into the memory space of
      user process, but in this case we're taking a PMR and mapping it
      into kernel virtual space.  We keep the same function name for
      symmetry as this allows the higher layers of the software stack
      to not care whether they are user mode or kernel
    */

    psPMR = hPMR;

    eError = PMRAcquireKernelMappingData(psPMR,
                                         0,
                                         0,
                                         &pvKernelAddress,
                                         &uiLength,
                                         &hPriv);
    if (eError != PVRSRV_OK)
    {
        goto e0;
    }
    
    *phOSMMapPrivDataOut = hPriv;
    *ppvMappingAddressOut = pvKernelAddress;
    *puiMappingLengthOut = uiLength;

    PVR_ASSERT(*puiMappingLengthOut == uiPMRSize);

    return PVRSRV_OK;

    /*
      error exit paths follow
    */

 e0:
    PVR_ASSERT(eError != PVRSRV_OK);
    return eError;
}

IMG_INTERNAL void
OSMUnmapPMR(IMG_HANDLE hBridge,
            IMG_HANDLE hPMR,
            IMG_HANDLE hOSMMapPrivData,
            void *pvMappingAddress,
            IMG_SIZE_T uiMappingLength)
{
    PMR *psPMR;

    PVR_UNREFERENCED_PARAMETER(hBridge);
    PVR_UNREFERENCED_PARAMETER(pvMappingAddress);
    PVR_UNREFERENCED_PARAMETER(uiMappingLength);

    psPMR = hPMR;
    PMRReleaseKernelMappingData(psPMR,
                                hOSMMapPrivData);
}
